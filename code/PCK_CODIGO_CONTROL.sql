create or replace PACKAGE            "PCK_CODIGO_CONTROL" AS 

/*
Autor:Victor Hugo Gonzales
Fecha: 10/10/2018
DescripciÃ³n: Procedimientos relacionados a la generacion de codigos de control de una factura
*/


  FUNCTION REDONDEAR (PI_NUMERO IN NUMBER, PI_DIGITOS IN PLS_INTEGER) RETURN NUMBER ;
  FUNCTION CONCATENAR_VERHOEFF(PI_VALOR NUMBER, PI_NRO_VECES PLS_INTEGER) RETURN VARCHAR2;
  FUNCTION OBTENER_VERHOEFFS(PI_VALOR NUMBER, PI_NRO_VECES PLS_INTEGER) RETURN VARCHAR2; 
    FUNCTION OBTENER_SUMATORIA_ASCII(PI_CADENA IN VARCHAR2, PI_POS_INICIAL IN PLS_INTEGER, pi_STEP IN PLS_INTEGER)  RETURN NUMBER;

  /* Genera el cÃ³digo de control de una factura, segÃºn las especificaciones del Servicio de Impuestos Nacionales.*/
  FUNCTION GENERAR( PI_NUMERO_AUTORIZACION IN NUMBER, -- Numero de autorizaciÃ³n de la factura
                    PI_NUMERO_FACTURA IN NUMBER, -- Numero de una factura
                    PI_NIT IN NUMBER, -- Nit del cliente
                    PI_FECHA IN DATE, -- Fecha de emisiÃ³n de la factura
                    PI_MONTO NUMBER , -- Monto total de la factura
                    PI_CLAVE VARCHAR2 -- Clave de la dosificaciÃ³n provisto por el SIN
                  )
  RETURN VARCHAR2;


/*
DECLARE
v_condigo_control VARCHAR2(1000);
BEGIN

  V_CONDIGO_CONTROL := PCK_CODIGO_CONTROL.GENERAR(PI_NUMERO_AUTORIZACION =>416801800089374, 
                                                PI_NUMERO_FACTURA =>35308, 
                                                PI_NIT => 0, 
                                                PI_FECHA => TO_DATE('2018/10/04','yyyy/mm/dd'), 
                                                PI_MONTO =>5.0, 
                                                PI_CLAVE =>'quB3FuAT3W=B(V74TQ3gxcAFA)=2kWa*uR=3h=4bmD%*8Lp7BW7Ug9@WS_gYMT(H');
  dbms_output.put_line('V_CONDIGO_CONTROL:'||V_CONDIGO_CONTROL);
end;

  
SELECT F.NUMEROAUTORIZACION, F.NUMEROFACTURA, F.NITCICLIENTE, F.FECHAEMISION, F.IMPORTE, F.CODIGOCONTROL
,PCK_CODIGO_CONTROL.GENERAR(F.NUMEROAUTORIZACION,F.NUMEROFACTURA,F.NITCICLIENTE,F.FECHAEMISION,F.IMPORTE,D.CLAVE)
,D.clave
FROM TIGOCASH.TC_FACTURA F, TIGOCASH.TC_DOSIFICACION D
WHERE F.NUMEROAUTORIZACION = D.NUMEROAUTORIZACION 
and f.fechaemision > sysdate -60;
*/

END PCK_CODIGO_CONTROL;
/

create or replace PACKAGE BODY            "PCK_CODIGO_CONTROL" AS
/*
Autor:Victor Hugo Gonzales
Fecha: 10/10/2018
DescripciÃ³n: Procedimientos relacionados a la generacion de codigos de control de una factura
*/
  FUNCTION REDONDEAR (PI_NUMERO IN NUMBER, PI_DIGITOS IN PLS_INTEGER) RETURN NUMBER IS
    V_NUMBER NUMBER := PI_NUMERO + 0.001;
    V_CIFRAS PLS_INTEGER := POWER(10,PI_DIGITOS);
  BEGIN
    RETURN ROUND(V_NUMBER * V_CIFRAS)/ V_CIFRAS;
  END;
  
  FUNCTION CONCATENAR_VERHOEFF(PI_VALOR NUMBER, PI_NRO_VECES PLS_INTEGER) RETURN VARCHAR2 IS
    v_result VARCHAR2(32000) := to_char(pi_valor);
  BEGIN
    FOR I IN 0..PI_NRO_VECES-1 LOOP
      v_result := v_result ||to_char(pck_verhoeff.obtener_Verhoeff(v_result)) ;
    END LOOP;
    return v_result;
  END;

  FUNCTION OBTENER_VERHOEFFS(PI_VALOR NUMBER, PI_NRO_VECES PLS_INTEGER) RETURN VARCHAR2 IS
    v_result VARCHAR2(32000) := to_char(pi_valor);
  BEGIN
    FOR I IN 0..PI_NRO_VECES-1 LOOP
      v_result := v_result ||to_char(pck_verhoeff.obtener_Verhoeff(v_result)) ;
    END LOOP;
    V_RESULT := SUBSTR(V_RESULT, LENGTH(V_RESULT)- PI_NRO_VECES+1, LENGTH(V_RESULT));
    RETURN V_RESULT;
  END;  

  FUNCTION OBTENER_SUMATORIA_ASCII(PI_CADENA IN VARCHAR2, PI_POS_INICIAL IN PLS_INTEGER, pi_STEP IN PLS_INTEGER)  RETURN NUMBER IS
    V_SUMATORIA NUMBER := 0;
    I INTEGER := PI_POS_INICIAL;
    v_cadena_length PLS_INTEGER:= LENGTH(PI_CADENA);
  BEGIN
        WHILE (I<= V_CADENA_LENGTH) LOOP
            V_SUMATORIA := V_SUMATORIA + ASCII(SUBSTR(PI_CADENA, I,1));
            I := I + PI_STEP;
        END LOOP;
        
        RETURN V_SUMATORIA ;
    END;
    
/* Genera el cÃ³digo de control de una factura, segÃºn las especificaciones del Servicio de Impuestos Nacionales.*/
  FUNCTION GENERAR( PI_NUMERO_AUTORIZACION IN NUMBER, -- Numero de autorizaciÃ³n de la factura
                    PI_NUMERO_FACTURA IN NUMBER, -- Numero de una factura
                    PI_NIT IN NUMBER, -- Nit del cliente
                    PI_FECHA IN DATE, -- Fecha de emisiÃ³n de la factura
                    PI_MONTO NUMBER , -- Monto total de la factura
                    PI_CLAVE VARCHAR2 -- Clave de la dosificaciÃ³n provisto por el SIN
  ) RETURN VARCHAR2 AS
  V_CODIGO_CONTROL VARCHAR2(1000);
  V_FECHA_INTEGER PLS_INTEGER;
  V_MONTO NUMBER;
  v_NUMERO_FACTURA_VH VARCHAR2(1000);
  V_NIT_VH VARCHAR2(1000);
  V_FECHA_VH  VARCHAR2(1000);
  V_MONTO_VH VARCHAR2(1000);
  V_SUMATORIA  NUMBER;
  V_CINCO_VH   VARCHAR2(1000);
  VH1 PLS_INTEGER;
  VH2 PLS_INTEGER;
  VH3 PLS_INTEGER;
  VH4 PLS_INTEGER;
  VH5 PLS_INTEGER;
  V_SUB_CLAVE1 VARCHAR2(1000);
  V_SUB_CLAVE2 VARCHAR2(1000);
  V_SUB_CLAVE3 VARCHAR2(1000);
  V_SUB_CLAVE4 VARCHAR2(1000);
  V_SUB_CLAVE5 VARCHAR2(1000);
  V_SUB_CLAVE6 VARCHAR2(1000);
  V_AUTORIZACION_CLAVE VARCHAR2(1000);
  V_NUMERO_FACTURA_CLAVE VARCHAR2(1000);
  V_NIT_CLAVE VARCHAR2(1000);
  V_FECHA_CLAVE VARCHAR2(1000);
  V_MONTO_CLAVE VARCHAR2(1000);
  V_CADENA_ENCRIPTADA VARCHAR2(1000);
  V_SUMA_TOTAL      NUMBER;
  V_SUMA_PARCIAL1   NUMBER;
  V_SUMA_PARCIAL2   NUMBER;
  V_SUMA_PARCIAL3   NUMBER;
  V_SUMA_PARCIAL4   NUMBER;
  V_SUMA_PARCIAL5   NUMBER;
  V_MULT_PARCIAL1   NUMBER;
  V_MULT_PARCIAL2   NUMBER;
  V_MULT_PARCIAL3   NUMBER;
  V_MULT_PARCIAL4   NUMBER;
  V_MULT_PARCIAL5   NUMBER;
  v_suma_Base64     VARCHAR2(1000);
  BEGIN
    /* TAREA Se necesita implementaciÃ³n */
    V_FECHA_INTEGER := TO_NUMBER(TO_CHAR(PI_FECHA, 'yyyymmdd'));
    V_MONTO := REDONDEAR (PI_MONTO, 0);
    V_NUMERO_FACTURA_VH := CONCATENAR_VERHOEFF(PI_NUMERO_FACTURA, 2);
   -- dbms_output.put_line('V_NUMERO_FACTURA_VH:'||V_NUMERO_FACTURA_VH);
    V_NIT_VH := CONCATENAR_VERHOEFF(PI_NIT, 2);
    V_FECHA_VH := CONCATENAR_VERHOEFF(V_FECHA_INTEGER, 2);
    V_MONTO_VH := CONCATENAR_VERHOEFF(V_MONTO, 2);
    V_SUMATORIA := V_NUMERO_FACTURA_VH + V_NIT_VH + V_FECHA_VH + V_MONTO_VH;
    -- dbms_output.put_line('V_SUMATORIA:'||V_SUMATORIA);
    V_CINCO_VH := OBTENER_VERHOEFFS(V_SUMATORIA, 5);
    -- dbms_output.PUT_LINE('V_CINCO_VH :'||V_CINCO_VH );
    VH1 := to_number(SUBSTR(V_CINCO_VH, 1,1)) + 1;--obtengo el primer digito y sumarle 1
    VH2 := to_number(SUBSTR(V_CINCO_VH, 2,1)) + 1;
    VH3 := to_number(SUBSTR(V_CINCO_VH, 3,1)) + 1;
    VH4 := to_number(SUBSTR(V_CINCO_VH, 4,1)) + 1;
    VH5 := to_number(SUBSTR(V_CINCO_VH, 5,1)) + 1;
    -- dbms_output.put_line('VH1..5:'||VH1||'|'||VH2||'|'||VH3||'|'||VH4||'|'||VH5);
    V_SUB_CLAVE1 := SUBSTR(PI_CLAVE, 1, VH1);
    V_SUB_CLAVE2 := SUBSTR(PI_CLAVE, VH1+1, VH2);
    V_SUB_CLAVE3 := SUBSTR(PI_CLAVE, VH1+1 + VH2, VH3);
    V_SUB_CLAVE4 := SUBSTR(PI_CLAVE, VH1+1 + VH2 + VH3, VH4);
    V_SUB_CLAVE5 := SUBSTR(PI_CLAVE, VH1+1 + VH2 + VH3 + VH4, VH5);
    -- dbms_output.put_line('V_SUB_CLAVE1..5:'||V_SUB_CLAVE1||'|'||V_SUB_CLAVE2||'|'||V_SUB_CLAVE3||'|'||V_SUB_CLAVE4||'|'||V_SUB_CLAVE5);
    V_AUTORIZACION_CLAVE := TO_CHAR(PI_NUMERO_AUTORIZACION) || V_SUB_CLAVE1;
    V_NUMERO_FACTURA_CLAVE := TO_CHAR(V_NUMERO_FACTURA_VH) || V_SUB_CLAVE2;
    V_NIT_CLAVE := TO_CHAR(V_NIT_VH) || V_SUB_CLAVE3;
    V_FECHA_CLAVE := TO_CHAR(V_FECHA_VH) || V_SUB_CLAVE4;
    V_MONTO_CLAVE := TO_CHAR(V_MONTO_VH) || V_SUB_CLAVE5;
    -- dbms_output.PUT_LINE('V_AUTORIZACION_CLAVE:'||V_AUTORIZACION_CLAVE);
     -- dbms_output.put_line('V_NUMERO_FACTURA_CLAVE:'||V_NUMERO_FACTURA_CLAVE);
    -- dbms_output.PUT_LINE('V_NIT_CLAVE:'||V_NIT_CLAVE);
     -- dbms_output.PUT_LINE('V_FECHA_CLAVE:'||V_FECHA_CLAVE);
     -- dbms_output.PUT_LINE('V_MONTO_CLAVE:'||V_MONTO_CLAVE);
    V_CADENA_ENCRIPTADA  := PCK_CIFRADOR_RC4.CIFRAR_RC4 (V_AUTORIZACION_CLAVE||V_NUMERO_FACTURA_CLAVE||V_NIT_CLAVE||V_FECHA_CLAVE||V_MONTO_CLAVE, PI_CLAVE || TO_CHAR(V_CINCO_VH));
     -- dbms_output.put_line('V_CADENA_ENCRIPTADA:'||V_CADENA_ENCRIPTADA);
    V_SUMA_TOTAL := OBTENER_SUMATORIA_ASCII(V_CADENA_ENCRIPTADA, 1, 1);
    V_SUMA_PARCIAL1 := OBTENER_SUMATORIA_ASCII(V_CADENA_ENCRIPTADA, 1, 5);
    V_SUMA_PARCIAL2 := OBTENER_SUMATORIA_ASCII(V_CADENA_ENCRIPTADA, 2, 5);
    V_SUMA_PARCIAL3 := OBTENER_SUMATORIA_ASCII(V_CADENA_ENCRIPTADA, 3, 5);
    V_SUMA_PARCIAL4 := OBTENER_SUMATORIA_ASCII(V_CADENA_ENCRIPTADA, 4, 5);
    V_SUMA_PARCIAL5 := OBTENER_SUMATORIA_ASCII(V_CADENA_ENCRIPTADA, 5, 5);
     -- dbms_output.PUT_LINE('V_SUMA_TOTAL y parciales 1..5:'||V_SUMA_TOTAL||'|'||V_SUMA_PARCIAL1||'|'||V_SUMA_PARCIAL2||'|'||V_SUMA_PARCIAL3||'|'||V_SUMA_PARCIAL4||'|'||V_SUMA_PARCIAL5);
    V_MULT_PARCIAL1 := TRUNC(V_SUMA_TOTAL * V_SUMA_PARCIAL1 / VH1);
    V_MULT_PARCIAL2 := TRUNC(V_SUMA_TOTAL * V_SUMA_PARCIAL2 / VH2);
    V_MULT_PARCIAL3 := TRUNC(V_SUMA_TOTAL * V_SUMA_PARCIAL3 / VH3);
    V_MULT_PARCIAL4 := TRUNC(V_SUMA_TOTAL * V_SUMA_PARCIAL4 / VH4);
    V_MULT_PARCIAL5 := trunc(V_SUMA_TOTAL * V_SUMA_PARCIAL5 / VH5);
 -- dbms_output.PUT_LINE('V_MULT_PARCIAL1..5:'||V_MULT_PARCIAL1||'|'||V_MULT_PARCIAL2||'|'||V_MULT_PARCIAL3||'|'||V_MULT_PARCIAL4||'|'||V_MULT_PARCIAL5);
    V_SUMA_BASE64 := PCK_BASE64.OBTENER_BASE64(V_MULT_PARCIAL1 + V_MULT_PARCIAL2 + V_MULT_PARCIAL3 + V_MULT_PARCIAL4 + V_MULT_PARCIAL5);
    V_CODIGO_CONTROL := PCK_CIFRADOR_RC4.CIFRAR_RC4 (V_SUMA_BASE64, PI_CLAVE || V_CINCO_VH);
     -- dbms_output.PUT_LINE('V_SUMA_BASE64:'||V_SUMA_BASE64);
    V_CODIGO_CONTROL := RTRIM(REGEXP_REPLACE( V_CODIGO_CONTROL, '(..)', '\1-' ), '-') ;
   -- dbms_output.PUT_LINE('V_CODIGO_CONTROL:'||V_CODIGO_CONTROL);
    RETURN v_codigo_control;
  END GENERAR;

END PCK_CODIGO_CONTROL;
/